{
  "data": [
    {
      "_id": "66367f5e0d552cf0a90e85e9",
      "title": "Two Sum",
      "acceptanceRate": 52.4,
      "accepted": 12.9,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an array of integers and a target value, determine if there are two numbers that add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
      "constraints": [],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Solutions include a brute force approach, using a hash table for efficient lookups, or sorting with two pointers.",
      "editorialRating": 4.5,
      "editorialVotes": { "1": 5, "2": 4 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 1,
      "similar": [],
      "submissions": 24.6,
      "testCases": [
        {
          "output": [0, 1],
          "explanation": "",
          "inputs": {
            "nums": [2, 7, 11, 15],
            "target": 9
          }
        },
        {
          "output": [1, 2],
          "explanation": "",
          "inputs": {
            "nums": [3, 2, 4],
            "target": 6
          }
        },
        {
          "output": [0, 1],
          "explanation": "",
          "inputs": {
            "nums": [3, 3],
            "target": 6
          }
        }
      ],
      "signature": {
        "parameters": [
          { "type": "List[int]", "name": "nums" },
          { "type": "int", "name": "target" }
        ],
        "returnType": "List[int]"
      },
      "topics": [
        "685491f4781604a302338d2c",
        "6855cbb3781604a302338d2e"
      ]
    },
    {
      "_id": "66367f5e0d552cf0a90e8609",
      "title": "Longest Substring Without Repeating Characters",
      "body": "Given a string s, find the length of the longest substring without repeating characters.",
      "acceptanceRate": 35.2,
      "accepted": 5.9,
      "submissions": 16.8,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "PrimeTimeTran"
      },
      "difficulty": "Medium",
      "frequency": "High",
      "constraints": [],
      "hints": [
        "Use a sliding window approach.",
        "Try using a set to store characters.",
        "When a duplicate character is found, move the left pointer."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 3,
      "similar": [],
      "testCases": [
        {
          "inputs": {
            "s": "abcabcbb"
          },
          "output": 3,
          "explanation": "\"abc\" is the longest substring."
        },
        {
          "inputs": {
            "s": "bbbbb"
          },
          "output": 1,
          "explanation": "\"b\" is the longest substring."
        },
        {
          "inputs": {
            "s": "pwwkew"
          },
          "output": 3,
          "explanation": "\"wke\" is the longest substring."
        }
      ],
      "signature": {
        "parameters": [{ "type": "str", "name": "s" }],
        "returnType": "int"
      },
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/6789",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "A sliding window approach using a hash set or a dictionary can efficiently solve this problem in linear time. You maintain a window and slide it forward while ensuring that all characters inside are unique.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 3, "2": 7 }
    },
    {
      "_id": "66367f5e0d552cf0a90e8614",
      "title": "Median of Two Sorted Arrays",
      "numLC": 4,
      "acceptanceRate": 31.6,
      "accepted": 15.3,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/13579",
        "username": "MedianFinder"
      },
      "body": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
      "constraints": [],
      "difficulty": "Hard",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "SortedArrayMaster"
      },
      "editorialBody": "The problem can be solved using binary search to partition the arrays into two parts such that elements on the left are smaller than elements on the right. Then, calculate the median based on the partitioned arrays.",
      "editorialRating": 4.9,
      "editorialVotes": { "1": 9, "2": 1 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 27.8,
      "testCases": [
        {
          "output": 2,
          "explanation": "",
          "inputs": { "nums1": [1, 3], "nums2": [2] }
        },
        {
          "output": 2.5,
          "explanation": "",
          "inputs": { "nums1": [1, 2], "nums2": [3, 4] }
        },
        {
          "output": 0,
          "explanation": "",
          "inputs": { "nums1": [0, 0], "nums2": [0, 0] }
        }
      ],
      "signature": {
        "parameters": [
          { "type": "List[int]", "name": "nums1" },
          { "type": "List[int]", "name": "nums2" }
        ],
        "returnType": "float"
      }
    },
    {
      "_id": "66367f5e0d552cf0a90e865b",
      "title": "Container With Most Water",
      "numLC": 11,
      "acceptanceRate": 50.3,
      "accepted": 32.1,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/75321",
        "username": "WaterContainerMaster"
      },
      "body": "Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "ContainerExpert"
      },
      "editorialBody": "The problem can be solved using a two-pointer approach. Start with two pointers at the beginning and end of the array, and move them towards each other while updating the maximum area.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 7, "2": 3 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 27.8,
      "testCases": [
        {
          "output": 49,
          "explanation": "",
          "inputs": {
            "height": [1, 8, 6, 2, 5, 4, 8, 3, 7]
          }
        },
        {
          "output": 1,
          "explanation": "",
          "inputs": {
            "height": [1, 1]
          }
        },
        {
          "output": 16,
          "explanation": "",
          "inputs": {
            "height": [4, 3, 2, 1, 4]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "height" }],
        "returnType": "int"
      }
    },
    {
      "_id": "66367f5e0d552cf0a90e8682",
      "title": "3Sum",
      "numLC": 15,
      "acceptanceRate": 28.6,
      "accepted": 20.5,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/98765",
        "username": "ThreeSumMaster"
      },
      "body": "Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Notice that the solution set must not contain duplicate triplets.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "ThreeSumExpert"
      },
      "editorialBody": "The problem can be solved by sorting the array and using a two-pointer approach to find triplets that sum up to zero. Handle duplicate triplets by skipping duplicates in the array.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 6, "2": 4 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 25.3,
      "testCases": [
        {
          "output": [
            [-1, -1, 2],
            [-1, 0, 1]
          ],
          "explanation": "",
          "inputs": {
            "nums": [-1, 0, 1, 2, -1, -4]
          }
        },
        {
          "output": [],
          "explanation": "",
          "inputs": {
            "nums": []
          }
        },
        { "output": [], "explanation": "", "inputs": { "nums": [0] } }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "List[List[int]]"
      }
    },
    {
      "_id": "66367f5e0d552cf0a90e875c",
      "title": "Valid Sudoku",
      "numLC": 36,
      "acceptanceRate": 45.6,
      "accepted": 40.2,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/98765",
        "username": "ValidSudokuMaster"
      },
      "body": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "ValidSudokuExpert"
      },
      "editorialBody": "The problem can be solved by checking each row, column, and sub-box separately for validity. Use hash sets to keep track of seen digits.",
      "editorialRating": 4.3,
      "editorialVotes": { "1": 6, "2": 4 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 29.4,
      "testCases": [
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "board": [
              ["5", "3", ".", ".", "7", ".", ".", ".", "."],
              ["6", ".", ".", "1", "9", "5", ".", ".", "."],
              [".", "9", "8", ".", ".", ".", ".", "6", "."],
              ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
              ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
              ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
              [".", "6", ".", ".", ".", ".", "2", "8", "."],
              [".", ".", ".", "4", "1", "9", ".", ".", "5"],
              [".", ".", ".", ".", "8", ".", ".", "7", "9"]
            ]
          }
        },
        {
          "output": false,
          "explanation": "",
          "inputs": {
            "board": [
              ["8", "3", ".", ".", "7", ".", ".", ".", "."],
              ["6", ".", ".", "1", "9", "5", ".", ".", "."],
              [".", "9", "8", ".", ".", ".", ".", "6", "."],
              ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
              ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
              ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
              [".", "6", ".", ".", ".", ".", "2", "8", "."],
              [".", ".", ".", "4", "1", "9", ".", ".", "5"],
              [".", ".", ".", ".", "8", ".", ".", "7", "9"]
            ]
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "board": [
              ["5", "3", ".", ".", "7", ".", ".", ".", "."],
              ["6", ".", ".", "1", "9", "5", ".", ".", "."],
              [".", "9", "8", ".", ".", ".", ".", "6", "."],
              ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
              ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
              ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
              [".", "6", ".", ".", ".", ".", "2", "8", "."],
              [".", ".", ".", "4", "1", "9", ".", ".", "5"],
              [".", ".", ".", ".", "8", ".", ".", "7", "9"]
            ]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[List[str]]", "name": "board" }],
        "returnType": "bool"
      }
    },
    {
      "_id": "6844bbfa438d7b9a15caa7cf",
      "title": "Group Anagrams",
      "acceptanceRate": 66.4,
      "accepted": 12.8,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "LC_Solutions"
      },
      "editorialBody": "A common solution involves using a hash map where the key is a representation of the sorted string (or a character frequency tuple), and the value is a list of anagrams. This results in O(n·k log k) time complexity with sorting, or O(n·k) using character count as the key.",
      "editorialRating": 4.8,
      "editorialVotes": { "1": 3, "2": 8 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 49,
      "similar": [],
      "submissions": 19.3,
      "testCases": [
        {
          "output": [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]],
          "explanation": "",
          "inputs": {
            "strs": ["eat", "tea", "tan", "ate", "nat", "bat"]
          }
        },
        {
          "output": [[""]],
          "explanation": "",
          "inputs": {
            "strs": [""]
          }
        },
        {
          "output": [["a"]],
          "explanation": "",
          "inputs": {
            "strs": ["a"]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[str]", "name": "strs" }],
        "returnType": "List[List[str]]"
      }
    },
    {
      "_id": "66367f5e0d552cf0a90e86bb",
      "title": "Longest Consecutive Sequence",
      "acceptanceRate": 48.7,
      "accepted": 8.1,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "SequenceSolver"
      },
      "body": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
      "constraints": ["0 <= nums.length <= 10⁵", "-10⁹ <= nums[i] <= 10⁹"],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "SequenceSolver"
      },
      "editorialBody": "The optimal solution uses a HashSet to store the elements, then checks for the start of a sequence by verifying that `num - 1` is not in the set. It then counts the length of the sequence starting from that number.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 6, "2": 3 },
      "frequency": "Medium",
      "hints": [
        "Think about what happens when you sort the array.",
        "Can you do it in O(n) using extra space?",
        "Try using a set and checking for the beginning of a sequence."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 128,
      "similar": [],
      "submissions": 16.5,
      "testCases": [
        {
          "output": 4,
          "explanation": "",
          "inputs": {
            "nums": [100, 4, 200, 1, 3, 2]
          }
        },
        {
          "output": 9,
          "explanation": "",
          "inputs": {
            "nums": [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "int"
      }
    },
    {
      "_id": "68449561e05ddd247bea6d2d",
      "title": "Contains Duplicate",
      "acceptanceRate": 59.6,
      "accepted": 18.7,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
      "constraints": [],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Common solutions include sorting the array and checking neighboring elements, or using a hash set to track seen values for O(n) time complexity.",
      "editorialRating": 4.3,
      "editorialVotes": { "1": 3, "2": 6 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 217,
      "similar": [],
      "submissions": 31.4,
      "testCases": [
        {
          "output": true,
          "explanation": "",
          "inputs": { "nums": [1, 2, 3, 1] }
        },
        {
          "output": false,
          "explanation": "",
          "inputs": {
            "nums": [1, 2, 3, 4]
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "bool"
      }
    },
    {
      "_id": "6844ba7876977e14d4795339",
      "title": "Valid Anagram",
      "difficulty": "Easy",
      "frequency": "High",
      "acceptanceRate": 65.5,
      "accepted": 1000,
      "isPublished": true,
      "isSubmitted": true,
      "submissions": 24.6,
      "author": {
        "username": "PrimeTimeTran",
        "urlAvatar": "https://example.com/avatar.jpg"
      },
      "body": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once.",
      "constraints": [],
      "testCases": [
        {
          "inputs": { "s": "anagram", "t": "nagaram" },
          "output": true,
          "explanation": ""
        },
        {
          "inputs": { "s": "rat", "t": "car" },
          "output": false,
          "explanation": ""
        }
      ],
      "hints": [
        "Check that the two strings have the same length",
        "Use a hash table (or Counter) to count characters",
        "Alternatively, sort both strings and compare"
      ],
      "similar": [],
      "editorialAuthor": {
        "username": "PrimeTimeTran",
        "urlAvatar": null
      },
      "editorialBody": "One approach is to check length first. Then either:\n\n1. **Hash‑table counting**: count frequencies of characters in `s`, then decrement with `t`. If any count mismatches, return false.\n\n2. **Sorting**: sort both `s` and `t` and compare equality.\n\nThe hash‑table method runs in O(n) time and uses O(1) extra space for fixed alphabet. The sorting method runs in O(nlogn).",
      "editorialRating": 4.2,
      "editorialVotes": { "1": 8, "2": 3 },
      "numLC": 242,
      "signature": {
        "parameters": [
          { "type": "str", "name": "s" },
          { "type": "str", "name": "t" }
        ],
        "returnType": "bool"
      }
    },
    {
      "_id": "66367f5e0d552cf0a90e86aa",
      "title": "Product of Array Except Self",
      "acceptanceRate": 66.3,
      "accepted": 21.7,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/67890",
        "username": "ArrayMaster"
      },
      "body": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The solution must be done without using division and in O(n) time.",
      "constraints": [
        "2 <= nums.length <= 10⁵",
        "-30 <= nums[i] <= 30",
        "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
      ],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/67890",
        "username": "ArrayMaster"
      },
      "editorialBody": "You can solve this by first building a prefix product array, then a suffix product array, and multiplying the two. For constant space (excluding the output), calculate the result in two passes: left-to-right and right-to-left.",
      "editorialRating": 4.8,
      "editorialVotes": { "1": 10, "2": 7, "3": 1 },
      "frequency": "High",
      "hints": [
        "Try to find a solution that doesn't use division.",
        "Think about how the product of elements before and after an index can help.",
        "Build two arrays: left products and right products."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 238,
      "similar": [],
      "submissions": 32.4,
      "testCases": [
        {
          "output": [24, 12, 8, 6],
          "explanation": "",
          "inputs": {
            "nums": [1, 2, 3, 4]
          }
        },
        {
          "output": [0, 0, 9, 0, 0],
          "explanation": "",
          "inputs": {
            "nums": [-1, 1, 0, -3, 3]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "List[int]"
      }
    },
    {
      "_id": "66367f5e0d552cf0a90e86cc",
      "title": "Island Perimeter",
      "acceptanceRate": 77.2,
      "accepted": 9.4,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/24680",
        "username": "GridMaster"
      },
      "body": "You are given `row x col` grid representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water. Grid cells are connected **4-directionally** (horizontally and vertically). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have lakes (water inside that isn't connected to the water around the island). Return the **perimeter** of the island.",
      "constraints": [
        "row == grid.length",
        "col == grid[i].length",
        "1 <= row, col <= 100",
        "grid[i][j] is 0 or 1",
        "There is exactly one island in grid"
      ],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/24680",
        "username": "GridMaster"
      },
      "editorialBody": "Loop through every cell. When you find land, add 4 to the perimeter, but subtract 2 for every neighboring land cell (right and bottom) to avoid double-counting shared edges.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 4, "2": 2 },
      "frequency": "Medium",
      "hints": [
        "How many sides does a single land cell contribute to the perimeter?",
        "Check each neighboring cell for water or boundary to count sides.",
        "Optimize by counting shared edges between adjacent land cells."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 463,
      "similar": [],
      "submissions": 14.2,
      "testCases": [
        {
          "output": 16,
          "explanation": "",
          "inputs": {
            "grid": [
              [0, 1, 0, 0],
              [1, 1, 1, 0],
              [0, 1, 0, 0],
              [1, 1, 0, 0]
            ]
          }
        },
        {
          "output": 4,
          "explanation": "",
          "inputs": {
            "grid": [[1]]
          }
        },
        {
          "output": 4,
          "explanation": "",
          "inputs": {
            "grid": [[1, 0]]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[List[int]]", "name": "grid" }],
        "returnType": "int"
      }
    }
  ]
}
