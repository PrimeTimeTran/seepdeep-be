{
  "data": [
    {
      "_id": "66367f5e0d552cf0a90e85e9",
      "title": "Two Sum",
      "acceptanceRate": 52.4,
      "accepted": 12.9,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an array of integers and a target value, determine if there are two numbers that add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
      "constraints": [],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Solutions include a brute force approach, using a hash table for efficient lookups, or sorting with two pointers.",
      "editorialRating": 4.5,
      "editorialVotes": { "1": 5, "2": 4 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 1,
      "similar": [],
      "submissions": 24.6,
      "testCases": [
        {
          "output": [0, 1],
          "explanation": "",
          "inputs": {
            "nums": [2, 7, 11, 15],
            "target": 9
          }
        },
        {
          "output": [1, 2],
          "explanation": "",
          "inputs": {
            "nums": [3, 2, 4],
            "target": 6
          }
        },
        {
          "output": [0, 1],
          "explanation": "",
          "inputs": {
            "nums": [3, 3],
            "target": 6
          }
        }
      ],
      "signature": {
        "parameters": [
          { "type": "List[int]", "name": "nums" },
          { "type": "int", "name": "target" }
        ],
        "returnType": "List[int]"
      },
      "topics": ["685491f4781604a302338d2c", "6855cbb3781604a302338d2e"]
    },
    {
      "_id": "66367f5e0d552cf0a90e8609",
      "title": "Longest Substring Without Repeating Characters",
      "body": "Given a string s, find the length of the longest substring without repeating characters.",
      "acceptanceRate": 35.2,
      "accepted": 5.9,
      "submissions": 16.8,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "PrimeTimeTran"
      },
      "difficulty": "Medium",
      "frequency": "High",
      "constraints": [],
      "hints": [
        "Use a sliding window approach.",
        "Try using a set to store characters.",
        "When a duplicate character is found, move the left pointer."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 3,
      "similar": [],
      "testCases": [
        {
          "inputs": {
            "s": "abcabcbb"
          },
          "output": 3,
          "explanation": "\"abc\" is the longest substring."
        },
        {
          "inputs": {
            "s": "bbbbb"
          },
          "output": 1,
          "explanation": "\"b\" is the longest substring."
        },
        {
          "inputs": {
            "s": "pwwkew"
          },
          "output": 3,
          "explanation": "\"wke\" is the longest substring."
        }
      ],
      "signature": {
        "parameters": [{ "type": "str", "name": "s" }],
        "returnType": "int"
      },
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/6789",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "A sliding window approach using a hash set or a dictionary can efficiently solve this problem in linear time. You maintain a window and slide it forward while ensuring that all characters inside are unique.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 3, "2": 7 },
      "topics": ["685491fd781604a302338d2d"]
    },
    {
      "_id": "66367f5e0d552cf0a90e8614",
      "title": "Median of Two Sorted Arrays",
      "numLC": 4,
      "acceptanceRate": 31.6,
      "accepted": 15.3,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/13579",
        "username": "MedianFinder"
      },
      "body": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
      "constraints": [],
      "difficulty": "Hard",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "SortedArrayMaster"
      },
      "editorialBody": "The problem can be solved using binary search to partition the arrays into two parts such that elements on the left are smaller than elements on the right. Then, calculate the median based on the partitioned arrays.",
      "editorialRating": 4.9,
      "editorialVotes": { "1": 9, "2": 1 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 27.8,
      "testCases": [
        {
          "output": 2,
          "explanation": "",
          "inputs": { "nums1": [1, 3], "nums2": [2] }
        },
        {
          "output": 2.5,
          "explanation": "",
          "inputs": { "nums1": [1, 2], "nums2": [3, 4] }
        },
        {
          "output": 0,
          "explanation": "",
          "inputs": { "nums1": [0, 0], "nums2": [0, 0] }
        }
      ],
      "signature": {
        "parameters": [
          { "type": "List[int]", "name": "nums1" },
          { "type": "List[int]", "name": "nums2" }
        ],
        "returnType": "float"
      },
      "topics": []
    },
    {
      "_id": "66367f5e0d552cf0a90e865b",
      "title": "Container With Most Water",
      "numLC": 11,
      "acceptanceRate": 50.3,
      "accepted": 32.1,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/75321",
        "username": "WaterContainerMaster"
      },
      "body": "Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "ContainerExpert"
      },
      "editorialBody": "The problem can be solved using a two-pointer approach. Start with two pointers at the beginning and end of the array, and move them towards each other while updating the maximum area.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 7, "2": 3 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 27.8,
      "testCases": [
        {
          "output": 49,
          "explanation": "",
          "inputs": {
            "height": [1, 8, 6, 2, 5, 4, 8, 3, 7]
          }
        },
        {
          "output": 1,
          "explanation": "",
          "inputs": {
            "height": [1, 1]
          }
        },
        {
          "output": 16,
          "explanation": "",
          "inputs": {
            "height": [4, 3, 2, 1, 4]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "height" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "_id": "66367f5e0d552cf0a90e8682",
      "title": "3Sum",
      "numLC": 15,
      "acceptanceRate": 28.6,
      "accepted": 20.5,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/98765",
        "username": "ThreeSumMaster"
      },
      "body": "Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Notice that the solution set must not contain duplicate triplets.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "ThreeSumExpert"
      },
      "editorialBody": "The problem can be solved by sorting the array and using a two-pointer approach to find triplets that sum up to zero. Handle duplicate triplets by skipping duplicates in the array.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 6, "2": 4 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 25.3,
      "testCases": [
        {
          "output": [
            [-1, -1, 2],
            [-1, 0, 1]
          ],
          "explanation": "",
          "inputs": {
            "nums": [-1, 0, 1, 2, -1, -4]
          }
        },
        {
          "output": [],
          "explanation": "",
          "inputs": {
            "nums": []
          }
        },
        { "output": [], "explanation": "", "inputs": { "nums": [0] } }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "List[List[int]]"
      },
      "topics": []
    },
    {
      "_id": "66367f5e0d552cf0a90e875c",
      "title": "Valid Sudoku",
      "numLC": 36,
      "acceptanceRate": 45.6,
      "accepted": 40.2,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/98765",
        "username": "ValidSudokuMaster"
      },
      "body": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "ValidSudokuExpert"
      },
      "editorialBody": "The problem can be solved by checking each row, column, and sub-box separately for validity. Use hash sets to keep track of seen digits.",
      "editorialRating": 4.3,
      "editorialVotes": { "1": 6, "2": 4 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "similar": [],
      "submissions": 29.4,
      "testCases": [
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "board": [
              ["5", "3", ".", ".", "7", ".", ".", ".", "."],
              ["6", ".", ".", "1", "9", "5", ".", ".", "."],
              [".", "9", "8", ".", ".", ".", ".", "6", "."],
              ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
              ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
              ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
              [".", "6", ".", ".", ".", ".", "2", "8", "."],
              [".", ".", ".", "4", "1", "9", ".", ".", "5"],
              [".", ".", ".", ".", "8", ".", ".", "7", "9"]
            ]
          }
        },
        {
          "output": false,
          "explanation": "",
          "inputs": {
            "board": [
              ["8", "3", ".", ".", "7", ".", ".", ".", "."],
              ["6", ".", ".", "1", "9", "5", ".", ".", "."],
              [".", "9", "8", ".", ".", ".", ".", "6", "."],
              ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
              ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
              ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
              [".", "6", ".", ".", ".", ".", "2", "8", "."],
              [".", ".", ".", "4", "1", "9", ".", ".", "5"],
              [".", ".", ".", ".", "8", ".", ".", "7", "9"]
            ]
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "board": [
              ["5", "3", ".", ".", "7", ".", ".", ".", "."],
              ["6", ".", ".", "1", "9", "5", ".", ".", "."],
              [".", "9", "8", ".", ".", ".", ".", "6", "."],
              ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
              ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
              ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
              [".", "6", ".", ".", ".", ".", "2", "8", "."],
              [".", ".", ".", "4", "1", "9", ".", ".", "5"],
              [".", ".", ".", ".", "8", ".", ".", "7", "9"]
            ]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[List[str]]", "name": "board" }],
        "returnType": "bool"
      },
      "topics": []
    },
    {
      "_id": "6844bbfa438d7b9a15caa7cf",
      "title": "Group Anagrams",
      "acceptanceRate": 66.4,
      "accepted": 12.8,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "constraints": [],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "LC_Solutions"
      },
      "editorialBody": "A common solution involves using a hash map where the key is a representation of the sorted string (or a character frequency tuple), and the value is a list of anagrams. This results in O(n·k log k) time complexity with sorting, or O(n·k) using character count as the key.",
      "editorialRating": 4.8,
      "editorialVotes": { "1": 3, "2": 8 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 49,
      "similar": [],
      "submissions": 19.3,
      "testCases": [
        {
          "output": [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]],
          "explanation": "",
          "inputs": {
            "strs": ["eat", "tea", "tan", "ate", "nat", "bat"]
          }
        },
        {
          "output": [[""]],
          "explanation": "",
          "inputs": {
            "strs": [""]
          }
        },
        {
          "output": [["a"]],
          "explanation": "",
          "inputs": {
            "strs": ["a"]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[str]", "name": "strs" }],
        "returnType": "List[List[str]]"
      },
      "topics": []
    },
    {
      "_id": "66367f5e0d552cf0a90e86bb",
      "title": "Longest Consecutive Sequence",
      "acceptanceRate": 48.7,
      "accepted": 8.1,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "SequenceSolver"
      },
      "body": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
      "constraints": ["0 <= nums.length <= 10⁵", "-10⁹ <= nums[i] <= 10⁹"],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/54321",
        "username": "SequenceSolver"
      },
      "editorialBody": "The optimal solution uses a HashSet to store the elements, then checks for the start of a sequence by verifying that `num - 1` is not in the set. It then counts the length of the sequence starting from that number.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 6, "2": 3 },
      "frequency": "Medium",
      "hints": [
        "Think about what happens when you sort the array.",
        "Can you do it in O(n) using extra space?",
        "Try using a set and checking for the beginning of a sequence."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 128,
      "similar": [],
      "submissions": 16.5,
      "testCases": [
        {
          "output": 4,
          "explanation": "",
          "inputs": {
            "nums": [100, 4, 200, 1, 3, 2]
          }
        },
        {
          "output": 9,
          "explanation": "",
          "inputs": {
            "nums": [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "_id": "68449561e05ddd247bea6d2d",
      "title": "Contains Duplicate",
      "acceptanceRate": 59.6,
      "accepted": 18.7,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
      "constraints": [],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Common solutions include sorting the array and checking neighboring elements, or using a hash set to track seen values for O(n) time complexity.",
      "editorialRating": 4.3,
      "editorialVotes": { "1": 3, "2": 6 },
      "frequency": "High",
      "hints": [],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 217,
      "similar": [],
      "submissions": 31.4,
      "testCases": [
        {
          "output": true,
          "explanation": "",
          "inputs": { "nums": [1, 2, 3, 1] }
        },
        {
          "output": false,
          "explanation": "",
          "inputs": {
            "nums": [1, 2, 3, 4]
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "bool"
      },
      "topics": []
    },
    {
      "_id": "6844ba7876977e14d4795339",
      "title": "Valid Anagram",
      "difficulty": "Easy",
      "frequency": "High",
      "acceptanceRate": 65.5,
      "accepted": 1000,
      "isPublished": true,
      "isSubmitted": true,
      "submissions": 24.6,
      "author": {
        "username": "PrimeTimeTran",
        "urlAvatar": "https://example.com/avatar.jpg"
      },
      "body": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once.",
      "constraints": [],
      "testCases": [
        {
          "inputs": { "s": "anagram", "t": "nagaram" },
          "output": true,
          "explanation": ""
        },
        {
          "inputs": { "s": "rat", "t": "car" },
          "output": false,
          "explanation": ""
        }
      ],
      "hints": [
        "Check that the two strings have the same length",
        "Use a hash table (or Counter) to count characters",
        "Alternatively, sort both strings and compare"
      ],
      "similar": [],
      "editorialAuthor": {
        "username": "PrimeTimeTran",
        "urlAvatar": null
      },
      "editorialBody": "One approach is to check length first. Then either:\n\n1. **Hash‑table counting**: count frequencies of characters in `s`, then decrement with `t`. If any count mismatches, return false.\n\n2. **Sorting**: sort both `s` and `t` and compare equality.\n\nThe hash‑table method runs in O(n) time and uses O(1) extra space for fixed alphabet. The sorting method runs in O(nlogn).",
      "editorialRating": 4.2,
      "editorialVotes": { "1": 8, "2": 3 },
      "numLC": 242,
      "signature": {
        "parameters": [
          { "type": "str", "name": "s" },
          { "type": "str", "name": "t" }
        ],
        "returnType": "bool"
      },
      "topics": []
    },
    {
      "_id": "66367f5e0d552cf0a90e86aa",
      "title": "Product of Array Except Self",
      "acceptanceRate": 66.3,
      "accepted": 21.7,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/67890",
        "username": "ArrayMaster"
      },
      "body": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The solution must be done without using division and in O(n) time.",
      "constraints": [
        "2 <= nums.length <= 10⁵",
        "-30 <= nums[i] <= 30",
        "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
      ],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/67890",
        "username": "ArrayMaster"
      },
      "editorialBody": "You can solve this by first building a prefix product array, then a suffix product array, and multiplying the two. For constant space (excluding the output), calculate the result in two passes: left-to-right and right-to-left.",
      "editorialRating": 4.8,
      "editorialVotes": { "1": 10, "2": 7, "3": 1 },
      "frequency": "High",
      "hints": [
        "Try to find a solution that doesn't use division.",
        "Think about how the product of elements before and after an index can help.",
        "Build two arrays: left products and right products."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 238,
      "similar": [],
      "submissions": 32.4,
      "testCases": [
        {
          "output": [24, 12, 8, 6],
          "explanation": "",
          "inputs": {
            "nums": [1, 2, 3, 4]
          }
        },
        {
          "output": [0, 0, 9, 0, 0],
          "explanation": "",
          "inputs": {
            "nums": [-1, 1, 0, -3, 3]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "List[int]"
      },
      "topics": []
    },
    {
      "title": "Island Perimeter",
      "acceptanceRate": 77.2,
      "accepted": 9.4,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/24680",
        "username": "GridMaster"
      },
      "body": "You are given `row x col` grid representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water. Grid cells are connected **4-directionally** (horizontally and vertically). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have lakes (water inside that isn't connected to the water around the island). Return the **perimeter** of the island.",
      "constraints": [
        "row == grid.length",
        "col == grid[i].length",
        "1 <= row, col <= 100",
        "grid[i][j] is 0 or 1",
        "There is exactly one island in grid"
      ],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/24680",
        "username": "GridMaster"
      },
      "editorialBody": "Loop through every cell. When you find land, add 4 to the perimeter, but subtract 2 for every neighboring land cell (right and bottom) to avoid double-counting shared edges.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 4, "2": 2 },
      "frequency": "Medium",
      "hints": [
        "How many sides does a single land cell contribute to the perimeter?",
        "Check each neighboring cell for water or boundary to count sides.",
        "Optimize by counting shared edges between adjacent land cells."
      ],
      "isPublished": true,
      "isSubmitted": true,
      "numLC": 463,
      "similar": [],
      "submissions": 14.2,
      "testCases": [
        {
          "output": 16,
          "explanation": "",
          "inputs": {
            "grid": [
              [0, 1, 0, 0],
              [1, 1, 1, 0],
              [0, 1, 0, 0],
              [1, 1, 0, 0]
            ]
          }
        },
        {
          "output": 4,
          "explanation": "",
          "inputs": {
            "grid": [[1]]
          }
        },
        {
          "output": 4,
          "explanation": "",
          "inputs": {
            "grid": [[1, 0]]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[List[int]]", "name": "grid" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "Valid Parentheses",
      "acceptanceRate": 48.1,
      "accepted": 11.2,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets are closed by the same type of brackets.\n2. Open brackets are closed in the correct order.\n3. Every closing bracket has a corresponding open bracket of the same type.",
      "constraints": [
        "1 <= s.length <= 10⁴",
        "s consists of parentheses only: '()[]{}'"
      ],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "A common solution uses a stack to track opening brackets. For every closing bracket, check if it matches the top of the stack. If the stack is empty or mismatched, return false. If the stack is empty at the end, the string is valid.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 7, "2": 3 },
      "frequency": "Very High",
      "hints": [
        "Use a stack to process the parentheses.",
        "Check matching pairs as you go.",
        "Watch for early mismatches or leftover open brackets."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 20,
      "similar": [],
      "submissions": 30.4,
      "testCases": [
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "s": "()"
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "s": "()[]{}"
          }
        },
        {
          "output": false,
          "explanation": "",
          "inputs": {
            "s": "(]"
          }
        },
        {
          "output": false,
          "explanation": "",
          "inputs": {
            "s": "([)]"
          }
        },
        {
          "output": true,
          "explanation": "",
          "inputs": {
            "s": "{[]}"
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "str", "name": "s" }],
        "returnType": "bool"
      },
      "topics": ["68577abbff85feed0e9e4811", "68577acfff85feed0e9e4812"]
    },
    {
      "title": "Flood Fill",
      "acceptanceRate": 55.0,
      "accepted": 9.2,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/733author",
        "username": "PrimeTimeTran"
      },
      "body": "An image is represented by an m x n integer grid image, where image[i][j] is the pixel value. Given a starting pixel (sr, sc) and a new color, perform a \"flood fill\" on the image. Return the modified image.",
      "constraints": [
        "m == image.length",
        "n == image[i].length",
        "1 <= m, n <= 50",
        "0 <= image[i][j], newColor < 2¹⁶",
        "0 <= sr < m",
        "0 <= sc < n"
      ],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/editor733",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Use DFS or BFS to traverse 4-directionally from the start pixel, recoloring all connected pixels matching the original color. Avoid infinite loops by checking bounds and whether you've already changed the color.",
      "editorialRating": 4.5,
      "editorialVotes": { "1": 12, "2": 4 },
      "frequency": "High",
      "hints": [
        "Record the original color before starting.",
        "Stop recursion when pixel is out of bounds or color mismatched or already newColor.",
        "Use a stack or recursion for DFS (or queue for BFS)."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 733,
      "similar": [],
      "submissions": 18.7,
      "testCases": [
        {
          "inputs": {
            "image": [
              [1, 1, 1],
              [1, 1, 0],
              [1, 0, 1]
            ],
            "sr": 1,
            "sc": 1,
            "newColor": 2
          },
          "output": [
            [2, 2, 2],
            [2, 2, 0],
            [2, 0, 1]
          ],
          "explanation": "All connected 1’s from (1,1) are recolored to 2."
        },
        {
          "inputs": {
            "image": [
              [0, 0, 0],
              [0, 0, 0]
            ],
            "sr": 0,
            "sc": 0,
            "newColor": 0
          },
          "output": [
            [0, 0, 0],
            [0, 0, 0]
          ],
          "explanation": "New color equals original color; no change."
        }
      ],
      "signature": {
        "parameters": [
          { "type": "List[List[int]]", "name": "image" },
          { "type": "int", "name": "sr" },
          { "type": "int", "name": "sc" },
          { "type": "int", "name": "newColor" }
        ],
        "returnType": "List[List[int]]"
      },
      "topics": ["68579774ff85feed0e9e4813"]
    },
    {
      "title": "Find the Town Judge",
      "acceptanceRate": 51.9,
      "accepted": 7.3,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n1. The town judge trusts nobody.\n2. Everybody (except for the town judge) trusts the town judge.\n3. There is exactly one person that satisfies properties 1 and 2.\n\nYou are given an integer `n` representing the number of people, and an array `trust` where `trust[i] = [a, b]` representing that the person labeled `a` trusts the person labeled `b`.\n\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.",
      "constraints": [
        "1 <= n <= 1000",
        "0 <= trust.length <= 10⁴",
        "trust[i].length == 2",
        "All trust[i] are unique",
        "1 <= a, b <= n",
        "a != b"
      ],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Track the net trust score for each person: +1 for being trusted, -1 for trusting someone. The town judge should have a score of `n - 1` and not trust anyone. Iterate through the trust list to calculate these scores and find the person who meets the condition.",
      "editorialRating": 4.5,
      "editorialVotes": { "1": 5, "2": 2 },
      "frequency": "High",
      "hints": [
        "Create an array to track trust counts.",
        "Increase the count for the person being trusted, and decrease it for the person trusting.",
        "The judge will have trust count of n - 1."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 997,
      "similar": [],
      "submissions": 15.7,
      "testCases": [
        {
          "output": 2,
          "explanation": "Everyone trusts person 2, and person 2 trusts nobody.",
          "inputs": {
            "n": 2,
            "trust": [[1, 2]]
          }
        },
        {
          "output": -1,
          "explanation": "Person 1 trusts person 2, and person 2 trusts person 1. No judge.",
          "inputs": {
            "n": 2,
            "trust": [
              [1, 2],
              [2, 1]
            ]
          }
        },
        {
          "output": 3,
          "explanation": "Persons 1 and 2 trust person 3, and person 3 trusts nobody.",
          "inputs": {
            "n": 3,
            "trust": [
              [1, 3],
              [2, 3]
            ]
          }
        },
        {
          "output": -1,
          "explanation": "No one has exactly n - 1 people trusting them.",
          "inputs": {
            "n": 3,
            "trust": [
              [1, 3],
              [2, 3],
              [3, 1]
            ]
          }
        }
      ],
      "signature": {
        "parameters": [
          { "type": "int", "name": "n" },
          { "type": "List[List[int]]", "name": "trust" }
        ],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "Number of Islands",
      "acceptanceRate": 57.3,
      "accepted": 13.4,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 300",
        "grid[i][j] is '0' or '1'"
      ],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore each island. Iterate through every cell in the grid; when you find a '1', increment the island count and start DFS/BFS to mark all connected '1's as visited (by flipping them to '0' or using a visited set).",
      "editorialRating": 4.8,
      "editorialVotes": { "1": 12, "2": 5 },
      "frequency": "Very High",
      "hints": [
        "Can you visit each cell and use DFS to mark visited land?",
        "Treat the grid as an implicit graph and traverse it using DFS or BFS.",
        "Consider modifying the input grid to mark visited cells."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 200,
      "similar": [],
      "submissions": 22.6,
      "testCases": [
        {
          "output": 1,
          "explanation": "There is only one island surrounded by water.",
          "inputs": {
            "grid": [
              ["1", "1", "1", "1", "0"],
              ["1", "1", "0", "1", "0"],
              ["1", "1", "0", "0", "0"],
              ["0", "0", "0", "0", "0"]
            ]
          }
        },
        {
          "output": 3,
          "explanation": "There are three separate islands.",
          "inputs": {
            "grid": [
              ["1", "1", "0", "0", "0"],
              ["1", "1", "0", "0", "0"],
              ["0", "0", "1", "0", "0"],
              ["0", "0", "0", "1", "1"]
            ]
          }
        },
        {
          "output": 0,
          "explanation": "All cells are water.",
          "inputs": {
            "grid": [
              ["0", "0", "0"],
              ["0", "0", "0"],
              ["0", "0", "0"]
            ]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[List[str]]", "name": "grid" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "Max Area of Island",
      "acceptanceRate": 69.1,
      "accepted": 6.1,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/12345",
        "username": "PrimeTimeTran"
      },
      "body": "You are given an `m x n` binary matrix `grid`. An island is a group of `1`s (representing land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value `1` in the island.\n\nReturn the maximum area of an island in `grid`. If there is no island, return `0`.",
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 50",
        "grid[i][j] is either 0 or 1"
      ],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/9876",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Use Depth-First Search (DFS) to explore each island and calculate its area. Iterate through each cell of the grid, and whenever you find a '1', start DFS to mark all connected land cells as visited while counting the area. Track the maximum area found during the traversal.",
      "editorialRating": 4.6,
      "editorialVotes": { "1": 8, "2": 4 },
      "frequency": "High",
      "hints": [
        "Can you use DFS to count the area of each island?",
        "Consider marking visited land to avoid recounting.",
        "Try keeping track of the max area during your traversal."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 695,
      "similar": [],
      "submissions": 9.8,
      "testCases": [
        {
          "output": 5,
          "explanation": "The island in the middle has an area of 6.",
          "inputs": {
            "grid": [
              [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
              [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
              [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
          }
        },
        {
          "output": 0,
          "explanation": "No land present in the grid.",
          "inputs": {
            "grid": [
              [0, 0, 0],
              [0, 0, 0],
              [0, 0, 0]
            ]
          }
        },
        {
          "output": 3,
          "explanation": "There is one island of area 3.",
          "inputs": {
            "grid": [
              [1, 1, 0, 0],
              [1, 0, 0, 1],
              [0, 0, 0, 1]
            ]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[List[int]]", "name": "grid" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "Coin Change",
      "acceptanceRate": 44.3,
      "accepted": 3.5,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/56789",
        "username": "PrimeTimeTran"
      },
      "body": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the **fewest number of coins** that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
      "constraints": [
        "1 <= coins.length <= 12",
        "1 <= coins[i] <= 2⁴",
        "0 <= amount <= 10⁴"
      ],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/56789",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "This problem can be solved using dynamic programming. Create a DP array where `dp[i]` represents the minimum number of coins needed for amount `i`. Initialize `dp[0] = 0` and all other entries to `amount + 1` (as an effective infinity). Then for each coin, update `dp[i] = min(dp[i], dp[i - coin] + 1)` for all `i` from `coin` to `amount`.",
      "editorialRating": 4.8,
      "editorialVotes": { "1": 12, "2": 4 },
      "frequency": "High",
      "hints": [
        "Think recursively and use memoization or tabulation to avoid redundant calculations.",
        "What if you try all combinations of coins? How can you prune the search space?",
        "Try to reduce the problem to smaller subproblems and build up to the final solution."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 322,
      "similar": [],
      "submissions": 23.7,
      "testCases": [
        {
          "output": 3,
          "explanation": "11 = 5 + 5 + 1",
          "inputs": {
            "coins": [1, 2, 5],
            "amount": 11
          }
        },
        {
          "output": -1,
          "explanation": "It is not possible to make amount 3 with coins of 2.",
          "inputs": {
            "coins": [2],
            "amount": 3
          }
        },
        {
          "output": 0,
          "explanation": "No coins are needed to make amount 0.",
          "inputs": {
            "coins": [1],
            "amount": 0
          }
        }
      ],
      "signature": {
        "parameters": [
          { "type": "List[int]", "name": "coins" },
          { "type": "int", "name": "amount" }
        ],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "House Robber",
      "acceptanceRate": 48.6,
      "accepted": 5.2,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/102938",
        "username": "PrimeTimeTran"
      },
      "body": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return the **maximum amount of money** you can rob tonight **without alerting the police**.",
      "constraints": ["1 <= nums.length <= 100", "0 <= nums[i] <= 400"],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/102938",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "Use dynamic programming. Let `dp[i]` be the maximum amount that can be robbed from the first `i+1` houses. At each house `i`, you have two choices:\n- Rob it (and add its value to `dp[i-2]` since you can't rob `i-1`),\n- Or skip it (and take `dp[i-1]`).\nThe recurrence relation is: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`.\nInitialize `dp[0] = nums[0]`, `dp[1] = max(nums[0], nums[1])`.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 7, "2": 1 },
      "frequency": "High",
      "hints": [
        "Try every other house to avoid adjacent robberies.",
        "Think in terms of dynamic programming—what are the subproblems?",
        "What is the recurrence relation? Try to optimize space."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 198,
      "similar": [],
      "submissions": 17.8,
      "testCases": [
        {
          "output": 5,
          "explanation": "Rob house 1 (2) and house 3 (3).",
          "inputs": {
            "nums": [2, 1, 1, 3]
          }
        },
        {
          "output": 4,
          "explanation": "Rob house 1 (1) and house 3 (3).",
          "inputs": {
            "nums": [1, 2, 3, 1]
          }
        },
        {
          "output": 12,
          "explanation": "Rob house 1 (2), house 3 (10).",
          "inputs": {
            "nums": [2, 7, 9, 3, 1]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "House Robber II",
      "acceptanceRate": 39.5,
      "accepted": 2.8,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/102938",
        "username": "PrimeTimeTran"
      },
      "body": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle**. That means the **first house is the neighbor of the last one**. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses are broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the **maximum amount of money** you can rob tonight **without alerting the police**.",
      "constraints": ["1 <= nums.length <= 100", "0 <= nums[i] <= 1000"],
      "difficulty": "Medium",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/102938",
        "username": "PrimeTimeTran"
      },
      "editorialBody": "This is a variation of the House Robber problem. The only difference is that the houses form a **circle**, so the first and last houses are adjacent. To solve this, consider two cases:\n1. Rob houses from index 0 to n-2 (excluding the last house).\n2. Rob houses from index 1 to n-1 (excluding the first house).\nTake the maximum of these two results. Use the same DP approach as in House Robber (Problem 198) for each case.",
      "editorialRating": 4.7,
      "editorialVotes": { "1": 5, "2": 0 },
      "frequency": "Medium",
      "hints": [
        "Since the houses are in a circle, we can't rob both the first and the last house.",
        "Try transforming the circular problem into two linear ones.",
        "Use the solution from House Robber (Problem 198) on two slices of the array."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 213,
      "similar": [
        { "numLC": 198, "title": "House Robber" },
        { "numLC": 337, "title": "House Robber III" }
      ],
      "submissions": 14.2,
      "testCases": [
        {
          "output": 3,
          "explanation": "Rob house 1 (3), since you can't rob both the first and last.",
          "inputs": {
            "nums": [2, 3, 2]
          }
        },
        {
          "output": 4,
          "explanation": "Rob house 2 (3) and house 4 (1).",
          "inputs": {
            "nums": [1, 2, 3, 1]
          }
        },
        {
          "output": 0,
          "explanation": "No houses to rob.",
          "inputs": {
            "nums": [0]
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "List[int]", "name": "nums" }],
        "returnType": "int"
      },
      "topics": []
    },
    {
      "title": "Climbing Stairs",
      "acceptanceRate": 52.4,
      "accepted": 8.9,
      "author": {
        "urlAvatar": "https://avatars.leetcode.com/u/24680",
        "username": "FibonacciFan"
      },
      "body": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "constraints": ["1 <= n <= 45"],
      "difficulty": "Easy",
      "editorialAuthor": {
        "urlAvatar": "https://avatars.leetcode.com/u/24680",
        "username": "FibonacciFan"
      },
      "editorialBody": "This is a classic dynamic programming problem that reduces to computing the nth Fibonacci number. You can reach step `n` either from step `n-1` (by climbing 1 step) or from step `n-2` (by climbing 2 steps). So the total ways to reach step `n` is `dp[n] = dp[n-1] + dp[n-2]`. Use an array or two variables to store intermediate results.",
      "editorialRating": 4.5,
      "editorialVotes": { "1": 4, "2": 1 },
      "frequency": "Very High",
      "hints": [
        "To reach step `n`, you can either come from step `n-1` or step `n-2`.",
        "What is the base case?",
        "Think recursively and use memoization to avoid recalculating."
      ],
      "isPublished": true,
      "isSubmitted": false,
      "numLC": 70,
      "similar": [
        { "numLC": 746, "title": "Min Cost Climbing Stairs" },
        { "numLC": 198, "title": "House Robber" }
      ],
      "submissions": 19.6,
      "testCases": [
        {
          "output": 2,
          "explanation": "There are two ways: [1 step + 1 step] or [2 steps].",
          "inputs": {
            "n": 2
          }
        },
        {
          "output": 3,
          "explanation": "Three ways: [1+1+1], [1+2], [2+1].",
          "inputs": {
            "n": 3
          }
        },
        {
          "output": 1,
          "explanation": "Only one way: [1].",
          "inputs": {
            "n": 1
          }
        }
      ],
      "signature": {
        "parameters": [{ "type": "int", "name": "n" }],
        "returnType": "int"
      },
      "topics": []
    }
  ]
}
